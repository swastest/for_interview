# Junit5

* Какую концептуальную разницу между junit и testNg можешь выделить. Почему понравился тот или иной фреймворк? 
* Какие аннотации джиюнита знаете? По порядку исполнения 
* Знакомы ли вы с экстеншинами? Для чего они нужны, какова цель? Перечислите знакомые экстеншены и что они делают?
  (ParameterResolver - какие методы содержит в себе что делает ) участвует в параметризованных тестах (реализовано джиюнитом), 
  инжектит данные из кастомного расширения в параметры тестового метода
```java
static class IntegerResolver implements ParameterResolver {

    @Override
    public boolean supportsParameter(ParameterContext parameterContext,
            ExtensionContext extensionContext) {

        return parameterContext.getParameter().getType() == int.class;
    }

    @Override
    public Object resolveParameter(ParameterContext parameterContext,
            ExtensionContext extensionContext) {

        return 2;
    }

}
```
* Какой механизм джавы использует у себя под капотом джиюнит? 

# DB (jdbc)
* Расскажи, как под капотом работает hibernate (вывод на голый jdbc), если в резюме написано 
* что такое jdbc?  Назови основные интерфейсы jdbc
   (jdbc - апи джавы, не фреймворк, описание апи для взаимодействиями какими то данными (набор интерфейсов) - реляц и не реляц и произвольные файлы)
![Establishing-JDBC-Connection-in-Java.png](..%2F..%2F..%2F..%2Fimages%2FEstablishing-JDBC-Connection-in-Java.png)
* что необходимо подключить в зависимость для того чтобы начать работать с jdbc? (реализацию драйвер менеджера)
* назови отличия statement и prepare statement
 ```text
Особенности Statement:

Выполнение SQL-кода: SQL-запросы компилируются и выполняются каждый раз при их вызове.
Инъекции SQL: Подвержен атакам SQL-инъекций, если значения параметров запроса формируются вручную.
Производительность: Поскольку запрос компилируется каждый раз, производительность может быть ниже по сравнению с PreparedStatement, особенно для повторяющихся запросов.

Особенности PreparedStatement:

Параметризация: Позволяет задавать параметры в запросе вместо использования строковых конкатенаций, что делает код более читабельным и защищенным.
Безопасность: Предотвращает SQL-инъекции, так как параметры передаются отдельно от SQL-кода и не могут быть интерпретированы как часть команды SQL.
Производительность: Запрос компилируется один раз, а затем может многократно выполняться с разными параметрами, что улучшает производительность для повторяющихся запросов.
Удобство использования: PreparedStatement автоматически приводит параметры к правильным типам данных, что снижает риск ошибок.
```


# Ui (selenide selenoid)
* Как вы запускали UI тесты в пайплайне? Селеноид как был настроен? Как вы указывали для тестов, что нужно было именно данный селеноид использовать? 


# Паттерны проектирования
* Какие паттерны проектирования применяли и пример (кратко)



# HTTP 
* Работали/знакомы с gRpc? Поверх какого протокола работает? (http 2.0), какие преимущества?  Где применяется?


# Java collections
* Для чего нужны коллекции? 
* в чем отличия/сходства ArrayList и HashMap - можно ли сравнивать между собой?
* 

* Как работает HashMap при попытке сохранить в него два элемента по ключам с одинаковым hashCode(), 
но для которых equals() == false?


* Какая коллекция реализует дисциплину обслуживания FIFO?
```text
FIFO, First-In-First-Out («первым пришел-первым ушел») - по этому принципу построена коллекция Queue.
```

# equals hashcode 
* Правила переопределения методов equals hashcode 
```text
Правила переопределения метода equals
1. Рефлексивность: Объект должен быть равен самому себе.
2. Симметричность: Если объект x равен объекту y, то и объект y должен быть равен объекту x.
3. Транзитивность: Если объект x равен объекту y, и объект y равен объекту z, то объект x должен быть равен объекту z.
4. Согласованность: Результат вызова метода equals должен быть одинаковым при многократных вызовах, если состояние 
объектов не изменилось.
5. Сравнение с null: Любой объект должен быть не равен null. 

Правила переопределения метода hashCode
1. Согласованность с equals: Если два объекта равны в соответствии с методом equals, то они должны иметь одинаковый
 hashCode.
2. Согласованность: Если объект не изменился, то результат вызова метода hashCode должен быть постоянным 
при многократных вызовах.
3. Разные объекты могут иметь одинаковый hashCode: Если два объекта не равны, они могут иметь одинаковый hashCode, 
но это не желательно, так как это снижает производительность хэш-коллекций.

Рекомендации:
* Поля для сравнения: Используйте те же поля для сравнения в методах equals и hashCode.
* Используйте Objects.hash(): Этот метод удобно использовать для вычисления хэш-кода на основе нескольких полей.
* Не изменяйте поля, используемые в equals и hashCode: После добавления объекта в коллекцию, 
не следует изменять поля, используемые в этих методах, так как это может нарушить работу коллекций.
```

* Для чего нужен метод hashCode()?
* Есть ли какие-либо рекомендации о том, какие поля следует использовать при подсчете hashCode()?
```text
Общий совет: выбирать поля, которые с большой долью вероятности будут различаться. Для этого необходимо использовать 
уникальные, лучше всего примитивные поля, например, такие как id, uuid. При этом нужно следовать правилу, 
если поля задействованы при вычислении hashCode(), то они должны быть задействованы и при выполнении equals().
```

# FunctionalInterface 
* Какой интерфейс можно называть функциональным?
* Какие основные функциональные интерфейсы знаете? 
* Где применяется интерфейс Predicate<T> 
```text
часто используется в сочетании с методами filter(), removeIf() 
```
* Где применяется интерфейс Function<T,R>
```text
Работа с коллекциями и Streams API:
Function<T, R> часто используется в методах map() и flatMap() для преобразования элементов в коллекциях и потоках (Stream).

В классе Optional метод map() использует Function<T, R> для преобразования значения, если оно присутствует, 
или возвращает пустой Optional, если значение отсутствует.
```


# Exception 
* Расскажи об иерархии исключений, на какие группы глобально их можно разделить?
* Нужно ли обрабатывать runtime exception? почему? в каких случаях?
```text
Когда следует обрабатывать RuntimeException?

* Если нужно предоставить более понятное сообщение об ошибке: 
Иногда можно поймать RuntimeException, чтобы дать пользователю более понятное сообщение или предпринять 
какие-то действия для исправления ситуации.
* Если есть специфическое бизнес-правило: 
В некоторых случаях в приложении может быть бизнес-логика, которая требует специальной обработки определённых ситуаций,
ведущих к выбросу RuntimeException.
* Желание сохранить работоспособность программы: 
В критичных приложениях можно ловить RuntimeException для предотвращения краха всей программы, 
если это допустимо с точки зрения логики работы приложения.
```
* Нужно ли обрабатывать error? 
* Что такое механизм try-with-resources?
```text
Данная конструкция, которая появилась в Java 7, позволяет использовать блок try-catch не заботясь о закрытии ресурсов,
 используемых в данном сегменте кода. Ресурсы объявляются в скобках сразу после try, 
 а компилятор уже сам неявно создаёт секцию finally, в которой и происходит освобождение занятых в блоке ресурсов. 
 Под ресурсами подразумеваются сущности, реализующие интерфейс java.lang.Autocloseable.
 
 Стоит заметить, что блоки catch и явный finally выполняются уже после того, как закрываются ресурсы в неявном finally.
```